/**
 * Copyright (c) 2013 SAP
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the SAP nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL SAP BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.sopeco.plugin.std.analysis;

import java.util.ArrayList;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sopeco.engine.analysis.IScreeningAnalysisResult;
import org.sopeco.engine.analysis.IScreeningAnalysisStrategy;
import org.sopeco.engine.analysis.ParameterEffect;
import org.sopeco.engine.analysis.ScreeningDesignResult;
import org.sopeco.engine.registry.ISoPeCoExtension;
import org.sopeco.persistence.dataset.AbstractDataSetColumn;
import org.sopeco.persistence.dataset.DataSetAggregated;
import org.sopeco.persistence.dataset.ParameterValue;
import org.sopeco.persistence.entities.definition.AnalysisConfiguration;
import org.sopeco.persistence.entities.definition.ParameterDefinition;
import org.sopeco.persistence.entities.definition.ParameterValueAssignment;
import org.sopeco.plugin.std.analysis.common.AbstractAnalysisStrategy;

/**
 * The Analysis Adapter for screening designs. Only compatible with data
 * generated by a screening exploration strategy.
 * 
 * @author Pascal Meier
 * @author Dennis Westermann
 * 
 */
public class ScreeningAnalysisStrategy extends AbstractAnalysisStrategy implements IScreeningAnalysisStrategy {

	private static Logger logger = LoggerFactory.getLogger(ScreeningAnalysisStrategy.class);

	/**
	 * Defines the types of interactions that will be calculated. A depth-value
	 * of 2,3,... means that interactions of two, three,... parameters are
	 * calculated. A value of 1 indicates that only main effects will be
	 * calculated.
	 */
	private int interactionDepth;

	/**
	 * Defines if the data that will be analysed includes replicated
	 * measurements
	 */
	boolean useReplication = false;
	/**
	 * Defines if the data that will be analysed has been created using a
	 * randomized run order
	 */
	boolean useRandomization = false;
	/**
	 * List of the parameter variations describing the screened parameters
	 */
	List<ParameterValueAssignment> parameterVariations;

	/**
	 * The result object that has been created in the latest run of the
	 * analysis.
	 */
	ScreeningDesignResult latestAnalysisResult;

	public ScreeningAnalysisStrategy(ISoPeCoExtension<?> provider) {
		super(provider);
	}

	@Override
	public boolean supports(AnalysisConfiguration strategy) {
		return strategy.getName().equalsIgnoreCase(ScreeningAnalysisStrategyExtension.NAME);
	}

	@Override
	public void analyse(DataSetAggregated dataSet, AnalysisConfiguration strategy) {

		this.config = strategy;

		if (!(strategy.getName().equalsIgnoreCase(ScreeningAnalysisStrategyExtension.NAME))) {
			throw new IllegalArgumentException(strategy.getName()
					+ "is not supported by this analysis strategy (only \"" + ScreeningAnalysisStrategyExtension.NAME
					+ "\")");
		}

		logger.debug("Starting screening analysis.");

		init(config);

		deriveDependentAndIndependentParameters(dataSet, config);

		checkConfiguration(dataSet);

		latestAnalysisResult = new ScreeningDesignResult(strategy);

		if (useReplication) {
			throw new IllegalStateException("Use of replications is not yet implemented!");
			// TODO: Calculate mean of the observationParameter-Values over
			// all replications for parameter
			// level combinations with equal levels. Replications may be
			// used to get better results
			// because of using the mean -> effect of measurement errors not
			// as strong. May also be used
			// to estimate the effect of the error concerning how good the
			// design describes the linear model
			// underlying the analysis. (NOT how good the model is when
			// using it with the current
			// problem/function.
			// BUT: How to determine where replications begin/end in design
			// efficiently! New list for
			// mean-values and change/test in calculation of effects if
			// replication is used -> then use
			// new list?
			// Not yet implemented because it's not needed at all cost at
			// the moment.
		}

		List<ParameterEffect> mainEffects = calculateMainEffects(dataSet);
		for (ParameterEffect mainEffect : mainEffects) {
			latestAnalysisResult.addParameterEffect(mainEffect);
		}
		if (interactionDepth >= 2) {

			List<ParameterEffect> interactionEffects = calculateInteractionEffects(dataSet);
			for (ParameterEffect interactionEffect : interactionEffects) {
				latestAnalysisResult.addParameterEffect(interactionEffect);
			}
		}
	}

	/**
	 * Initializes the analyser using the configuration of the strategy.
	 * 
	 * @param strategy
	 *            configuration of the strategy
	 * @param dataSet
	 *            DataSetAggregated that is analysed
	 * @throws FrameworkException
	 */
	private void init(AnalysisConfiguration strategy) {

		interactionDepth = ScreeningAnalysisStrategyConfiguration.getInteractionDepth(strategy);
		useRandomization = ScreeningAnalysisStrategyConfiguration.randomizeRuns(strategy);
	}

	/**
	 * Tests if the data set is valid and if it contains the parameters
	 * specified in the configuration and the experimental design.
	 * 
	 * @param dataSet
	 *            analysed data
	 * @throws FrameworkException
	 */
	private void checkConfiguration(DataSetAggregated dataSet) {
		boolean valid = true;

		List<ParameterDefinition> analysisSpecParams = new ArrayList<ParameterDefinition>();
		analysisSpecParams.addAll(independentParameterDefinitions);

		for (ParameterDefinition param : analysisSpecParams) {
			if (!(dataSet.contains(param))) {
				valid = false;
				break;
			}
		}
		if (!dataSet.contains(dependentParameterDefintion)) {
			valid = false;
		}
		if (!valid) {
			throw new IllegalStateException("Invalid DataSet.");
		}
	}

	/**
	 * Returns the level of a parameter corresponding to it's specified
	 * parameter value.
	 * 
	 * @param value
	 *            parameter value of which the corresponding level will be
	 *            extracted
	 * @param maxValue
	 * @param minValue
	 * @return level of the parameter value (1, -1)
	 */
	private Integer getLevelToParamValue(ParameterValue<?> value, double minValue, double maxValue) {

		if (Math.abs((value.getValueAsDouble() - maxValue)) < 0.000001) {
			return 1;
		} else if (Math.abs(value.getValueAsDouble() - minValue) < 0.000001) {
			return -1;
		}

		return null;
	}

	/**
	 * Creates a list of all levels of a parameter from the specified dataSet.
	 * 
	 * @param selectedParameter
	 *            parameter for which the list of levels is created.
	 * @param dataSet
	 *            the analysed dataSet
	 * @return list of levels of the parameter extracted from the dataSet
	 */
	private List<Integer> getLevelsOfAllRunsByParam(ParameterDefinition selectedParameter, DataSetAggregated dataSet) {
		List<Integer> list = new ArrayList<Integer>();

		AbstractDataSetColumn<?> col = dataSet.getColumn(selectedParameter);

		for (Object pv : dataSet.getColumn(selectedParameter).getParameterValues()) {
			Integer level = getLevelToParamValue((ParameterValue<?>) pv, col.getMin(), col.getMax());
			if (level == null) {
				logger.warn("Value of parameter {} doesn't match any level.", ((ParameterValue<?>) pv).getParameter()
						.getFullName());
			} else {
				list.add(level);
			}

		}

		return list;
	}

	/**
	 * Calculates all the main effects of single parameters according to the
	 * experimental design used to get the measurement data.
	 * 
	 * @param dataSet
	 * @return the main effects of single parameters according to the
	 *         experimental design used to get the measurement data.
	 */
	private List<ParameterEffect> calculateMainEffects(DataSetAggregated dataSet) {

		List<ParameterEffect> effects = new ArrayList<ParameterEffect>();
		for (ParameterDefinition param : independentParameterDefinitions) {
			List<ParameterDefinition> analysedParameters = new ArrayList<ParameterDefinition>();
			analysedParameters.add(param);

			int plusCount = 0;
			int minusCount = 0;
			int runIndex = 0;
			double effectValue = 0.0;
			List<Integer> levelsOfAllRunsOfParam = getLevelsOfAllRunsByParam(param, dataSet);
			for (Integer level : levelsOfAllRunsOfParam) {

				double observationValue = ((ParameterValue<?>) dataSet.getColumn(dependentParameterDefintion)
						.getParameterValues().get(runIndex)).getValueAsDouble();
				if (level == 1) {
					effectValue = effectValue + observationValue;
					plusCount++;
				} else if (level == -1) {
					effectValue = effectValue - observationValue;
					minusCount++;
				} else if (level != 0) {
					throw new IllegalStateException("Illegal level provided.");
				}
				runIndex++;
			}

			effects.add(checkResultAndCreateEffectObject(analysedParameters, plusCount, minusCount, effectValue));
		}
		return effects;
	}

	/**
	 * Used to calculate all interaction effects of all the combinations of the
	 * analysed parameters with the specified depth of interactions. A depth of
	 * 4 means, that all combinations using 4 parameters and less (minimum 2)
	 * will be calculated if possible.
	 * 
	 * @return a list of all interaction effects of the specified depth (and
	 *         lower).
	 */
	private List<ParameterEffect> calculateInteractionEffects(DataSetAggregated dataSet) {
		if (interactionDepth > independentParameterDefinitions.size()) {
			throw new IllegalArgumentException("Desired depth of interaction effects is incorrect. Effects of depth "
					+ interactionDepth + " are requested, but there are only " + independentParameterDefinitions.size()
					+ " parameters.");
		}

		List<ParameterEffect> parameterEffects = new ArrayList<ParameterEffect>();

		int depth = interactionDepth;
		while (depth >= 2) {

			ArrayList<ParameterDefinition> workList = new ArrayList<ParameterDefinition>();
			workList.addAll(independentParameterDefinitions);

			List<ParameterDefinition> selectedParameters = new ArrayList<ParameterDefinition>();
			parameterEffects.addAll(handleInteractionsOfSpecifiedDepth(depth, selectedParameters, workList, dataSet));

			depth--;
		}

		return parameterEffects;

	}

	/**
	 * Method that calls itself recursively to walk through all possible
	 * combinations of configuration parameter interactions.
	 * 
	 * @param depth
	 *            current depth of interactions that will be handled
	 * @param selectedParameters
	 *            parameters that are selected to be combined with all
	 *            parameters of the working set.
	 * @param workList
	 *            set of parameters for which all combinations with the selected
	 *            parameters are derived
	 * @return a list of all parameter interaction effects
	 * @throws FrameworkException
	 */
	private List<ParameterEffect> handleInteractionsOfSpecifiedDepth(int depth,
			List<ParameterDefinition> selectedParameters, List<ParameterDefinition> workList, DataSetAggregated dataSet) {

		// System.out.print("Depth: " + depth + "/ Selected: ");
		// for (ParameterDefinition p : selectedParameters) {
		// System.out.print(p.getID() + " ");
		// }
		// System.out.print(" / Working: ");
		// for (ParameterDefinition p : workList) {
		// System.out.print(p.getID() + " ");
		// }
		// System.out.println();

		List<ParameterEffect> parameterEffects = new ArrayList<ParameterEffect>();

		// Select a parameter from the worklist
		if (depth > 2) {
			int newDepth = depth - 1; // Decrease the depth for the next
										// recursive call
			// Create a copy of the workList to avoid alteration of the original
			// list
			List<ParameterDefinition> newWorkList = new ArrayList<ParameterDefinition>();
			newWorkList.addAll(workList);

			// One parameter is selected and extracted from the workList and the
			// next interaction-depth is handled.
			// This is done for all but one parameter of the workList, so all
			// possible parameter combinations of the
			// current depth are handled. The extraction is done to avoid
			// multiple occurrences of the same combination.
			while (newWorkList.size() > 1) {
				ParameterDefinition extractedParam = newWorkList.remove(0);
				selectedParameters.add(extractedParam);
				parameterEffects.addAll(handleInteractionsOfSpecifiedDepth(newDepth, selectedParameters, newWorkList,
						dataSet));
				selectedParameters.remove(extractedParam);
			}

		} else { // Deepest level reached: So now we got a list of selected
					// parameters that will be combined with all the
					// parameters remaining in the workList. So we need to get
					// all interaction effects of the combinations of
					// the selected parameters and the working set with
					// getEffectsForAllCombinations(...)

			// Create a copy of the workList to avoid alteration of the original
			// list
			List<ParameterDefinition> newWorkList = new ArrayList<ParameterDefinition>();
			newWorkList.addAll(workList);

			while (newWorkList.size() > 1) {
				ParameterDefinition extractedParam = newWorkList.remove(0);
				selectedParameters.add(extractedParam);
				parameterEffects.addAll(getEffectsForAllCombinations(selectedParameters, newWorkList, dataSet));
				selectedParameters.remove(extractedParam);
			}
		}

		return parameterEffects;

	}

	/**
	 * Calculates the interaction effects for all combinations of the selected
	 * parameters together with all the single parameters of the workList.
	 * 
	 * @param selectedParams
	 *            parameters that will be combined with all single parameters of
	 *            the work list
	 * @param workList
	 *            list of parameters that will each be combined with the
	 *            selected parameters
	 * @param dataSet
	 *            the analysed dataSet
	 * @return list of the calculated interaction effects
	 * @throws FrameworkException
	 */
	private List<ParameterEffect> getEffectsForAllCombinations(List<ParameterDefinition> selectedParams,
			List<ParameterDefinition> workList, DataSetAggregated dataSet) {
		List<ParameterEffect> resultEffectsList = new ArrayList<ParameterEffect>();

		for (ParameterDefinition workParam : workList) {

			// Safe all handled parameters in a list
			List<ParameterDefinition> analysedParameters = new ArrayList<ParameterDefinition>();
			analysedParameters.addAll(selectedParams);
			analysedParameters.add(workParam);

			// Get the run levels of all parameters from the design
			List<List<Integer>> runLevelsList = new ArrayList<List<Integer>>();
			for (ParameterDefinition analysedParam : analysedParameters) {
				List<Integer> levelsOfAllRunsOfParam = getLevelsOfAllRunsByParam(analysedParam, dataSet);
				runLevelsList.add(levelsOfAllRunsOfParam);
			}

			// Calculate the effect of the current parameter combination
			int plusCount = 0; // number of interaction levels with value 1
			int minusCount = 0; // number of interaction levels with value -1
			double effectValueSum = 0.0; // value of the effect on the
											// observation parameter value

			AbstractDataSetColumn<?> depParamColumn = dataSet.getColumn(dependentParameterDefintion);
			int numberOfRuns = depParamColumn.size();
			for (int runIndex = 0; runIndex < numberOfRuns; runIndex++) {

				double observationValue = depParamColumn.getParameterValues().get(runIndex).getValueAsDouble();
				// Calculate the interaction level of the current run by
				// multiplying all the parameter levels
				int interactionLevel = 1;
				for (List<Integer> levels : runLevelsList) {
					int level = levels.get(runIndex);
					if (level == 1 || level == -1) {
						interactionLevel = interactionLevel * level;
					} else {
						throw new IllegalStateException("Illegal level provided.");
					}
				}

				// change the value of the total effect
				if (interactionLevel == 1) {
					effectValueSum = effectValueSum + observationValue;
					plusCount++;
				} else if (interactionLevel == -1) {
					effectValueSum = effectValueSum - observationValue;
					minusCount++;
				}
			}

			resultEffectsList.add(checkResultAndCreateEffectObject(analysedParameters, plusCount, minusCount,
					effectValueSum));

		}
		return resultEffectsList;
	}

	/**
	 * Tests if the calculation of the effect is valid and creates a new
	 * ParameterEffect-object.
	 * 
	 * @param analysedParameters
	 *            list of parameters partaking at the interaction
	 * @param plusCount
	 *            number of positive interaction levels defined in the design
	 * @param minusCount
	 *            number of negative interaction levels defined in the design
	 * @param effectValueSum
	 *            sum of the values of all the effects on the observation
	 *            parameter value
	 * @return ParameterEffect object describing the effect
	 * @throws FrameworkException
	 */
	private ParameterEffect checkResultAndCreateEffectObject(List<ParameterDefinition> analysedParameters,
			int plusCount, int minusCount, double effectValueSum) {
		// Check if the design is correct. It is necessary that there is an
		// equal amount of 1 and -1 levels.
		// If this isn't the case, then there is a problem with the design.
		// Maybe it doesn't support the
		// calculation of an interaction of the current depth.
		if (plusCount != minusCount) {
			throw new IllegalStateException("Number of 1 and -1 levels is not equal. Design is corrupt.");
		}
		double effectValue = effectValueSum / (plusCount + minusCount);

		ParameterEffect parameterEffect = new ParameterEffect(analysedParameters, dependentParameterDefintion,
				effectValue);
		return parameterEffect;
	}

	@Override
	public IScreeningAnalysisResult getScreeningAnalysisResult() {
		return this.latestAnalysisResult;
	}

}